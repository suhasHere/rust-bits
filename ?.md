
Brief explanation: `?` is syntactic sugar that propagates early returns 
via the `Try` trait. For a `Result<T, E>`, `expr?` yields the `T` on 
`Ok(T)` and returns early with `Err(From::from(E))` on `Err(E)`. 

For an `Option<T>`, `expr?` yields `T` on `Some(T)` and returns 
early `None` on `None`. The enclosing function must return a 
compatible type (e.g., `Result<..., _>` or `Option<...>`), and 
`?` will use `From` conversions for error types when needed.

Example and manual expansion:

```rust
// rust
use std::error::Error;
use std::fs;

fn read_number(path: &str) -> Result<i32, Box<dyn Error>> {
    // std::fs::read_to_string returns Result<String, std::io::Error>
    // the `?` propagates any io::Error as Err(...) from this function
    let s = fs::read_to_string(path)?;

    // parse() returns Result<i32, ParseIntError>
    // the `?` propagates parse errors as Err(...) (converted via From into Box<dyn Error>)
    let n: i32 = s.trim().parse()?;

    Ok(n)
}

/* Manual expansion of `let s = fs::read_to_string(path)?;`:
match fs::read_to_string(path) {
    Ok(s) => s,
    Err(e) => return Err(From::from(e)),
}
*/

/* Option example */
fn first_even(v: &[i32]) -> Option<i32> {
    // find(...) returns Option<&i32>; `?` returns early None if not found
    let &n = v.iter().find(|&&x| x % 2 == 0)?;
    Some(n)
}

/* Manual expansion of `let &n = v.iter().find(...)?;`:
let &n = match v.iter().find(|&&x| x % 2 == 0) {
    Some(r) => r,
    None => return None,
};
*/
```

Brief: `From::from` is the conversion function provided by 
the `From<T>` trait. The `?` operator uses `From::from` to convert an error value 
into the function's error type before returning it. Implement `From` for each error 
you want to accept, then `?` will automatically call `From::from` on `Err(...)`.

Example showing `From` impls, `?` usage, and the manual expansion that `?` desugars to:

```rust
// rust
use std::fs;
use std::num::ParseIntError;
use std::io::Error as IoError;

/// Custom error type collecting possible error kinds
#[derive(Debug)]
enum Error {
    Io(IoError),
    ParseInt(ParseIntError),
}

impl From<IoError> for Error {
    fn from(e: IoError) -> Self {
        Error::Io(e)
    }
}

impl From<ParseIntError> for Error {
    fn from(e: ParseIntError) -> Self {
        Error::ParseInt(e)
    }
}

/// Concise version using `?`
/// `?` will convert the underlying error via `From::from` to `Error`.
fn read_and_parse(path: &str) -> Result<i32, Error> {
    let s = fs::read_to_string(path)?;       // On Err(e): returns Err(From::from(e))
    let n: i32 = s.trim().parse()?;          // On Err(e): returns Err(From::from(e))
    Ok(n)
}

/// Manual expansion of the first `?` to show the `From::from` call:
fn read_and_parse_manual(path: &str) -> Result<i32, Error> {
    let s = match fs::read_to_string(path) {
        Ok(s) => s,
        Err(e) => return Err(From::from(e)), // explicit conversion here
    };

    let n: i32 = match s.trim().parse() {
        Ok(v) => v,
        Err(e) => return Err(From::from(e)), // explicit conversion here
    };

    Ok(n)
}
```
